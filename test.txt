const crypto = require('crypto');

const ALGORITHM = 'aes-128-gcm'; // 定义加密算法 (AES-128-GCM)
const PBKDF2_ITERATIONS = 100000; // 推荐的迭代次数，足够安全，但会增加计算时间
const KEY_LENGTH = 32; // AES-256密钥长度为32字节
const IV_LENGTH = 16; // CBC模式初始化向量的长度，对于AES-256是16字节
const SALT_LENGTH = 16; // 盐值长度，用于密钥派生

class Encryption {
    /**
     * 加密文本
     * @param {string} text 要加密的文本
     * @param {string} masterPassword 主密码，用于派生密钥
     * @returns {string} 加密后的文本，包括盐值、初始化向量和认证标签等信息
     */
    static encrypt(text, masterPassword) {
        try {
            // 1. 生成随机盐值 (SALT)
            const salt = crypto.randomBytes(SALT_LENGTH);

            // 2. 使用 masterPassword 和 sakt 派生出加密密钥
            const key = crypto.pbkdf2Sync(masterPassword, salt, PBKDF2_ITERATIONS, KEY_LENGTH, 'sha256');

            // 3. 生成随机初始化向量（IV）
            const iv = crypto.randomBytes(IV_LENGTH);

            // 4. 使用密钥和IV创建加密器
            const cipher = crypto.createCipheriv(ALGORITHM, key, iv);

            // 5. 使用加密器对文本进行加密，并以十六进制格式输出结果
            let encryptedText = cipher.update(text, 'utf8', 'hex');
            encryptedText += cipher.final('hex');

            // 6. 获取认证标签（GCM模式需要）
            const authTag = cipher.getAuthTag();

            // 7. 组合盐值、初始化向量和加密文本，以及认证标签
            const payload = {
                salt: salt.toString('hex'),
                iv: iv.toString('hex'),
                authTag: authTag.toString('hex'),
                encryptedData: encryptedText
            }

            // 8. 将payload转换为Base64编码的字符串以便存储
            return Buffer.from(JSON.stringify(payload)).toString('base64');
        } catch (error) {
            console.error('Encryption failed:', error);
            throw new Error('Encryption process failed');
        }
    }
    /**
     * 解密文本
     * @param {string} encryptedText 加密后的文本
     * @param {string} masterPassword 主密码，用于派生密钥
     * @returns {string} 解密后的文本
     */
    static decrypt(encryptedPayloadBase64, masterPassword) {
        try {
            // 1. 从Base64字符串解码payload
            const payload = JSON.parse(Buffer.from(encryptedPayloadBase64, 'base64').toString('utf8'));
            const { salt, iv, authTag, encryptedData } = payload;

            // 2. 使用相同的 masterPassword 和 sakt 重新派生出加密密钥
            const key = crypto.pbkdf2Sync(masterPassword, Buffer.from(salt, 'hex'), PBKDF2_ITERATIONS, KEY_LENGTH, 'sha256');

            // 3. 使用密钥和IV创建解密器
            const decipher = crypto.createDecipheriv(ALGORITHM, key, Buffer.from(iv, 'hex'));

            // 4. 设置认证标签（GCM模式需要）
            decipher.setAuthTag(Buffer.from(authTag, 'hex'));

            // 5. 使用解密器对加密文本进行解密，并以十六进制格式输出结果
            let decryptedText = decipher.update(encryptedData, 'hex', 'utf8');
            decryptedText += decipher.final('utf8');

            return decryptedText;
        } catch (error) {
            console.error('Decryption failed:', error);
            // 这可能意味着密码错误、数据被篡改或payload损坏
            throw new Error('Decryption failed. Incorrect master password or corrupted data.');
        }
    }

    /**
     * 生成随机密码
     * @param {number} length 密码长度，默认为12
     * @param {Object} options 选项，包括是否包含大写字母、小写字母、数字和符号等
     * @returns {string} 生成的随机密码
     */
    static generateRandomPassword(length = 12, options = {}) {
        // 生成随机密码的逻辑...
        const {
            includeUppercase = true,
            includeLowercase = true,
            includeNumbers = true,
            includeSymbols = true,
            excludeSimilar = true,
            excludeAmbiguous = true,
        } = options;

        let charset = '';

        // 根据选项构建字符集
        if (includeLowercase) {
            charset += excludeSimilar ? 'abcdefghjkmnpqrstuvwxyz' : 'abcdefghijklmnopqrstuvwxyz';
        }
        if (includeUppercase) {
            charset += excludeSimilar ? 'ABCDEFGHJKMNPQRSTUVWXYZ' : 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        }
        if (includeNumbers) {
            charset += excludeSimilar ? '23456789' : '0123456789';
        }
        if (includeSymbols) {
            charset += excludeAmbiguous ? '!@#$%^&*()_+-=[]{}|;:,.<>?' : '!@#$%^&*()_+-=[]{}|;:,.<>?`~\'"';
        }
        if (!charset) {
            throw new Error('At least one character set must be included');
        }

        let password = '';

        const randomValues = new Uint32Array(length); // 创建一个足够大的Uint32Array来存储随机数
        crypto.getRandomValues(randomValues); // 填充randomValues数组

        for (let i = 0; i < length; i++) {
            const index = randomValues[i] % charset.length; // 取模以确保索引在字符集长度范围内
            password += charset[index];
        }

        return password;
    }

    /**
     * 生成超强密码
     * @param {number} length 密码长度，默认为64
     * @returns {string} 生成的超强密码
     * 生成的密码特点: 包含大写、小写字母、数字和特殊符号，长度为64个字符。
     */
    static generateSuperStrongPassword(length = 64) {
        const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()-_=+[]{}|;:,.<>?';
        const bytes = crypto.randomBytes(length);
        let password = '';
        for (let i = 0; i < bytes.length; i++) {
            password += charset[bytes[i] % charset.length];
        }
        return password;
    }
}

module.exports = Encryption;
