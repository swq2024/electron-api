const multer = require('multer');
const createError = require('http-errors');
const logger = require('../utils/logger');

/**
 * 标准化失败响应工具函数
 * @param {object} res - Express 响应对象
 * @param {Error} error - 错误对象（支持 Sequelize/JWT/multer/http-errors/自定义业务错误等）
 * @returns {object} Express 响应对象（标准化 JSON 格式）
 */
const createFailResponse = (res, error) => {
  let statusCode = 500; // 默认服务器错误
  let responseMessage = '请求失败';
  let errors = ['服务器内部错误'];

  // 1. 自定义业务错误（优先处理，支持业务层抛出的特定错误）
  if (error.isOperational) {
    statusCode = error.statusCode;
    responseMessage = error.message;
    errors = Array.isArray(error.errors) ? error.errors : [error.errors || error.message];
  }

  // 2. Sequelize 数据库相关错误
  else if (error.name === 'SequelizeValidationError') {
    statusCode = 400;
    responseMessage = '数据验证失败';
    errors = error.errors.map(val => ({ field: val.path, message: val.message })); // 保留字段详情
  } else if (error.name === 'SequelizeUniqueConstraintError') {
    statusCode = 409; // 冲突
    const field = error.errors[0].path;
    responseMessage = `${field.charAt(0).toUpperCase() + field.slice(1)} 已存在`;
    errors = [responseMessage];
  } else if (error.name === 'SequelizeForeignKeyConstraintError') {
    statusCode = 400;
    responseMessage = '无效的关联 ID（外键约束失败）';
    errors = [responseMessage];
  } else if (error.name === 'SequelizeOptimisticLockError') {
    statusCode = 409;
    responseMessage = '请求冲突';
    errors = ['您提交的数据已被修改，请稍后重试'];
  }

  // 3. JWT 认证错误
  else if (error.name === 'JsonWebTokenError') {
    statusCode = 401;
    responseMessage = 'Token 无效，请重新登录';
    errors = [responseMessage];
  } else if (error.name === 'TokenExpiredError') {
    statusCode = 401;
    responseMessage = '会话已过期，请重新登录';
    errors = [responseMessage];
  }

  // 4. 文件上传错误（multer）
  else if (error instanceof multer.MulterError) {
    statusCode = error.code === 'LIMIT_FILE_SIZE' ? 413 : 400;
    responseMessage = error.code === 'LIMIT_FILE_SIZE' ? '文件大小超出限制' : '文件上传失败';
    errors = [error.message];
  }

  // 5. HTTP 标准错误（http-errors 库创建）
  else if (error instanceof createError.HttpError) {
    statusCode = error.status;
    responseMessage = error.message;
    errors = [error.message];
  }

  // 6. 未知错误（兜底处理）
  else {
    logger.error('服务器未知错误:', error); // 记录错误日志
    // 生产环境隐藏具体错误，开发环境暴露堆栈
    errors = process.env.NODE_ENV === 'development' ? [error.message, error.stack] : ['服务器内部错误'];
  }

  // 构建标准化响应格式
  const response = {
    status: false, // 布尔值标识请求状态（参考 test1.txt）
    message: responseMessage, // 简洁提示
    errors: Array.isArray(errors) ? errors : [errors] // 错误详情数组（统一格式）
  };

  // 开发环境额外返回错误堆栈（参考 errorHandler.js）
  if (process.env.NODE_ENV === 'development' && !error.isOperational && !error instanceof createError.HttpError) {
    response.stack = error.stack;
  }

  return res.status(statusCode).json(response);
};

module.exports = { createFailResponse };